import React, { useState, useEffect, useCallback } from 'react';
import { StyleSheet, View, ScrollView, TextInput, TouchableOpacity, Alert, ActivityIndicator, Platform, Text } from 'react-native';
import { useRouter, useFocusEffect } from 'expo-router';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import DateTimePicker, { DateTimePickerEvent } from '@react-native-community/datetimepicker';
import RNPickerSelect from 'react-native-picker-select';
import { FontAwesome } from '@expo/vector-icons';
import { useColorScheme } from '@/hooks/useColorScheme'; // Import useColorScheme
import { Colors } from '@/constants/Colors'; // Import Colors

const API_BASE_URL = "https://parmaexpo-app.vercel.app";

interface Patient { id: string; name: string; }
interface Doctor { id: string; name: string; }
interface Test { id: number; name: string; rate: number; component_id?: number; method?: string; } // Added method
interface SelectedTest extends Test { result?: string; comments?: string; status?: string; method?: string; } // Added status and allow overriding method


export default function AddReportScreen() {
    const router = useRouter();
    const colorScheme = (useColorScheme() ?? 'light') as 'light' | 'dark';

    const pickerSelectStyles = StyleSheet.create({
        inputIOS: {
            ...styles.input,
            paddingVertical: 0,
            color: Colors[colorScheme].text,
        },
        inputAndroid: {
            ...styles.input,
            paddingVertical: 0,
            color: Colors[colorScheme].text,
        },
        placeholder: {
            color: '#9EA0A4',
        },
        iconContainer: {
            top: 10,
            right: 12,
        },
    });
    // const [reportId, setReportId] = useState(''); // ID will be auto-generated by backend
    const [patientId, setPatientId] = useState<string | undefined>();
    const [doctorId, setDoctorId] = useState<string | undefined>();
    const [testDate, setTestDate] = useState(new Date());
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [selectedTests, setSelectedTests] = useState<SelectedTest[]>([]);
    const [costofSelectedTests, setCostOfSelectedTests] = useState<number>(0);
    const [overallComments, setOverallComments] = useState('');
    const [status, setStatus] = useState('Pending'); // Default status

    const [patients, setPatients] = useState<Patient[]>([]);
    const [doctors, setDoctors] = useState<Doctor[]>([]);
    const [availableTests, setAvailableTests] = useState<Test[]>([]);

    const [loading, setLoading] = useState(false);
    const [formLoading, setFormLoading] = useState(true); // For fetching dropdown data

    const loadFormData = async (isInitialLoad = false) => {
        if (isInitialLoad) setFormLoading(true);
        try {
            const [patientsRes, doctorsRes, testsRes] = await Promise.all([
                fetch(`${API_BASE_URL}/api/patients`),
                fetch(`${API_BASE_URL}/api/doctors`),
                fetch(`${API_BASE_URL}/api/tests`),
            ]);
            const patientsData = await patientsRes.json();
            const doctorsData = await doctorsRes.json();
            const testsData = await testsRes.json();

            if (patientsData.success) setPatients(patientsData.patients.map((p: any) => ({ id: p.patient_id, name: `${p.patients_name} (${p.patient_id})` })));
            else console.warn("Failed to load patients:", patientsData.message);

            if (doctorsData.success) setDoctors(doctorsData.doctors.map((d: any) => ({ id: d.doctor_id, name: `${d.doctor_name} (${d.doctor_id})` })));
            else console.warn("Failed to load doctors:", doctorsData.message);

            if (testsData.success) setAvailableTests(testsData.tests.map((t: any) => ({ id: t.test_id, name: t.test_name, rate: t.test_rate, component_id: t.default_component_id, method: t.method })));
            else console.warn("Failed to load tests:", testsData.message);

        } catch (error) {
            Alert.alert("Error", "Failed to load form data. Please check your network connection.");
            console.error("Form data load error:", error);
        } finally {
            if (isInitialLoad) setFormLoading(false);
        }
    };

    useEffect(() => {
        loadFormData(true);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadFormData(false); // Refresh data when screen comes into focus
        }, [])
    );

    useEffect(() => {
        const newCost = selectedTests.reduce((acc, currentTest) => {
            // Explicitly convert rate to a number.
            // (currentTest.rate || 0) handles null/undefined, then Number() converts.
            // E.g., Number("150.50") -> 150.50, Number(0) -> 0.
            return acc + Number(currentTest.rate || 0);
        }, 0);
        setCostOfSelectedTests(newCost);
    }, [selectedTests]);

    const onDateChange = (event: DateTimePickerEvent, selectedDate?: Date) => {
        const currentDate = selectedDate || testDate;
        setShowDatePicker(Platform.OS === 'ios'); // Keep open on iOS until done, close on Android
        if (event.type === "set" || Platform.OS === 'ios') { // "set" means user picked a date
            setTestDate(currentDate);
        }
        if (Platform.OS === 'android') {
            setShowDatePicker(false);
        }
    };

    const handleTestSelection = (test: Test) => {
        
        setSelectedTests(prev => {
            const isSelected = prev.find(t => t.id === test.id && t.component_id === test.component_id); // Assuming component_id helps uniquely identify a test variant
            if (isSelected) {

                return prev.filter(t => !(t.id === test.id && t.component_id === test.component_id));
            } else {
                // Initialize with default method from availableTest and overall status
                return [...prev, { ...test, result: '', comments: '', status: status, method: test.method || '' }];
            }
        });
    };

    const handleAddReport = async () => {
        if (!patientId || !doctorId || selectedTests.length === 0) { // reportId removed from validation
            Alert.alert("Validation Error", "Patient, Doctor, and at least one Test are required.");
            return;
        }
        setLoading(true);
        try {
            const reportData = {
                // report_id: reportId, // Removed, backend will generate
                patient_id: patientId,
                doctor_id: doctorId,
                test_date: testDate.toISOString().split('T')[0], // YYYY-MM-DD
                overall_comments: overallComments,
                status: status,
                tests_conducted: selectedTests.map(st => ({
                    test_id: st.id,
                    component_id: st.component_id, // Use the default_component_id from the fetched test
                    result: st.result,
                    method: st.method || "N/A", // Send individual method
                    comments: st.comments,
                    status: st.status || status, // Send individual status, fallback to overall
                })),
            };

            const response = await fetch(`${API_BASE_URL}/api/reports`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(reportData),
            });
            const responseData = await response.json();

            if (response.ok && responseData.success) {
                Alert.alert("Success", "Report added successfully!");
                router.back();
            } else {
                throw new Error(responseData.message || "Failed to add report");
            }
        } catch (error: any) {
            Alert.alert("Error", error.message || "An unexpected error occurred.");
            console.error("Add report error:", error);
        } finally {
            setLoading(false);
        }
    };

    if (formLoading) {
        return <ThemedView style={styles.centered}><ActivityIndicator size="large" /><ThemedText>Loading form...</ThemedText></ThemedView>;
    }

    return (
        <ScrollView style={styles.container} keyboardShouldPersistTaps="handled">
            <ThemedView style={styles.content}>
                <ThemedText type="title" style={styles.title}>Add New Report</ThemedText>

                <View style={styles.dropdownContainerWithAdd}>
                    <View style={{ flex: 1 }}>
                        <ThemedText style={styles.label}>Patient*</ThemedText>
                        <RNPickerSelect
                            onValueChange={(value) => setPatientId(value)}
                            items={patients.map(p => ({ label: p.name, value: p.id }))}
                            style={pickerSelectStyles}
                            value={patientId}
                            placeholder={{ label: "Select a patient...", value: null }}
                        />
                    </View>
                    <TouchableOpacity style={styles.addButton} onPress={() => router.push('/(screens)/add_patient')}>
                        <FontAwesome name="plus" size={20} color="white" />
                    </TouchableOpacity>
                </View>

                <View style={styles.dropdownContainerWithAdd}>
                    <View style={{ flex: 1 }}>
                        <ThemedText style={styles.label}>Referring Doctor*</ThemedText>
                        <RNPickerSelect
                            onValueChange={(value) => setDoctorId(value)}
                            items={doctors.map(d => ({ label: d.name, value: d.id }))}
                            style={pickerSelectStyles}
                            value={doctorId}
                            placeholder={{ label: "Select a doctor...", value: null }}
                        />
                    </View>
                    <TouchableOpacity style={styles.addButton} onPress={() => router.push('/(screens)/add_doctor')}>
                        <FontAwesome name="plus" size={20} color="white" />
                    </TouchableOpacity>
                </View>

                <ThemedText style={styles.label}>Test Date*</ThemedText>
                <TouchableOpacity onPress={() => setShowDatePicker(true)} style={styles.dateDisplay}>
                    <ThemedText>{testDate.toLocaleDateString()}</ThemedText>
                </TouchableOpacity>
                {showDatePicker && (
                    <DateTimePicker
                        value={testDate}
                        mode="date"
                        display={Platform.OS === 'ios' ? "spinner" : "default"}
                        onChange={onDateChange}
                    />
                )}

                <View style={styles.dropdownContainerWithAdd}>
                    <ThemedText style={[styles.label, { flex: 1 }]}>Tests* (Select multiple)</ThemedText>
                    <TouchableOpacity style={[styles.addButton, styles.addTestButton]} onPress={() => router.push('/(screens)/add_test')}>
                        <FontAwesome name="plus" size={16} color="white" />
                        <Text style={styles.addTestButtonText}> Test</Text>
                    </TouchableOpacity>
                </View>
                <View style={styles.checkboxListContainer}>
                    {availableTests.length > 0 ? availableTests.map(test => (
                        <TouchableOpacity
                            key={`${test.id}-${test.component_id || 'comp_none'}`}
                            onPress={() => handleTestSelection(test)}
                            style={styles.checkboxContainer}
                        >
                            <ThemedView style={[
                                styles.checkbox,
                                selectedTests.find(st => st.id === test.id && st.component_id === test.component_id) && styles.checkboxSelected
                            ]} />
                            <ThemedText style={styles.checkboxLabel}>{test.name} (₹{test.rate})</ThemedText>
                        </TouchableOpacity>
                    )) : <ThemedText>No tests available. Add tests first.</ThemedText>}
                </View>
                {selectedTests.length > 0 && (
                    <View style={styles.totalCostContainer}>
                        <ThemedText style={styles.totalCostText}>
                            Total Estimated Cost: ₹{costofSelectedTests}
                        </ThemedText>
                    </View>
                )}

                {/* TODO: Add input fields for result and comments for each selected test */}
                {selectedTests.length > 0 && (
                    <ThemedView style={styles.selectedTestsSection}>
                        <ThemedText type='subtitle'>Enter Results/Comments for Selected Tests:</ThemedText>
                        {selectedTests.map((st, index) => (
                            <View key={`selected-${st.id}-${index}`} style={styles.selectedTestItem}>
                                <ThemedText type='defaultSemiBold'>{st.name}</ThemedText>
                                <TextInput
                                    style={[styles.input, {color: Colors[colorScheme].text}]}
                                    placeholder='Result'
                                    placeholderTextColor={Colors[colorScheme].gray}
                                    value={st.result}
                                    onChangeText={(text) => {
                                        const newSelectedTests = [...selectedTests];
                                        newSelectedTests[index].result = text;
                                        setSelectedTests(newSelectedTests);
                                    }}
                                />
                                <ThemedText style={styles.labelMinor}>Method:</ThemedText>
                                <TextInput
                                    style={[styles.input, { color: Colors[colorScheme].text }]}
                                    placeholder='Method'
                                    placeholderTextColor={Colors[colorScheme].gray}
                                    value={st.method}
                                    onChangeText={(text) => {
                                        const newSelectedTests = [...selectedTests];
                                        newSelectedTests[index].method = text;
                                        setSelectedTests(newSelectedTests);
                                    }}
                                />
                                <ThemedText style={styles.labelMinor}>Status:</ThemedText>
                                <RNPickerSelect
                                    onValueChange={(value) => {
                                        const newSelectedTests = [...selectedTests];
                                        newSelectedTests[index].status = value;
                                        setSelectedTests(newSelectedTests);
                                    }}
                                    items={[
                                        { label: 'Pending', value: 'Pending' },
                                        { label: 'Completed', value: 'Completed' },
                                        { label: 'Partial', value: 'Partial' },
                                    ]}
                                    style={pickerSelectStyles}
                                    value={st.status}
                                    placeholder={{ label: "Select test status...", value: st.status || status }}
                                />
                                <TextInput
                                    style={[styles.input, styles.textAreaShort]}
                                    placeholder="Comments (optional)"
                                    placeholderTextColor={Colors[colorScheme].gray}
                                    value={st.comments || ''}
                                    onChangeText={(text) => {
                                        const newSelectedTests = [...selectedTests];
                                        newSelectedTests[index].comments = text;
                                        setSelectedTests(newSelectedTests);
                                    }}
                                    multiline
                                />
                            </View>
                        ))}
                    </ThemedView>
                )}


                <ThemedText style={styles.label}>Overall Comments</ThemedText>
                <TextInput
                    style={[styles.input, styles.textArea, {color: Colors[colorScheme].text}]}
                    value={overallComments}
                    onChangeText={setOverallComments}
                    multiline
                    placeholder="Any overall comments for the report"
                    placeholderTextColor={Colors[colorScheme].gray} />

                {/* <ThemedText style={styles.label}>Overall Report Status*</ThemedText>
                <RNPickerSelect
                    onValueChange={(value) => setStatus(value)}
                    items={[
                        { label: 'Pending', value: 'Pending' },
                        { label: 'Completed', value: 'Completed' },
                        { label: 'Partial', value: 'Partial' },
                        // Add more statuses as needed
                    ]}
                    style={pickerSelectStyles}
                    value={status}
                    placeholder={{ label: "Select status...", value: "Pending" }}
                /> */}

                <TouchableOpacity style={[styles.button, loading && styles.buttonDisabled]} onPress={handleAddReport} disabled={loading || formLoading}>
                    {loading || formLoading ? <ActivityIndicator color="#fff" /> : <ThemedText style={styles.buttonText}>Add Report</ThemedText>}
                </TouchableOpacity>
            </ThemedView>
        </ScrollView>
    );
}

// Define styles outside the component, or use useMemo for dynamic parts if needed inside
const styles = StyleSheet.create({
    container: { flex: 1 },
    content: { padding: 20, gap: 15 }, // Increased gap
    centered: { flex: 1, justifyContent: 'center', alignItems: 'center' },
    title: { textAlign: 'center', marginBottom: 20 },
    label: { fontSize: 16, marginBottom: 5, fontWeight: 'bold' },
    labelMinor: { fontSize: 14, marginTop: 8, marginBottom: 3, fontWeight: '600' },
    input: {
        borderWidth: 1,
        borderColor: '#ccc',
        paddingVertical: 8, // Adjusted padding
        paddingHorizontal: 12,
        borderRadius: 5,
        // marginBottom: 10, // Gap is handled by parent View
        // backgroundColor: 'transparent', // Let ThemedView handle background if input is wrapped
        // color will be set by TextInput's style prop directly or via a dynamic style object
        fontSize: 16,
    },
    textArea: { height: 100, textAlignVertical: 'top' },
    textAreaShort: { height: 60, textAlignVertical: 'top' },
    dateDisplay: {
        borderWidth: 1,
        // borderColor: '#ccc', // Will be themed
        padding: 12,
        borderRadius: 5,
        // marginBottom: 10,
        // backgroundColor: '#fff',
        justifyContent: 'center',
        minHeight: 40,
    },
    dropdownContainerWithAdd: {
        flexDirection: 'row',
        alignItems: 'flex-end', // Align + button with bottom of picker
        gap: 8,
        // marginBottom: 10,
    },
    addButton: {
        backgroundColor: 'rgb(249, 71, 208)',
        padding: 10,
        height: 42, // Match picker height
        borderRadius: 5,
        justifyContent: 'center',
        alignItems: 'center',
    },
    addTestButton: {
        paddingHorizontal: 10,
        paddingVertical: 8,
        height: 'auto',
        flexDirection: 'row',
    },
    addTestButtonText: {
        color: 'white',
        fontSize: 14,
        fontWeight: 'bold',
    },
    checkboxListContainer: {
        // maxHeight: 150, // Limit height and make scrollable if many tests
        borderWidth: 1,
        borderColor: '#ddd',
        borderRadius: 5,
        padding: 10,
    },
    totalCostContainer: {
        alignItems: 'flex-end', // Aligns children (the text) to the right
        marginTop: 8, // Spacing from the checkbox list
    },
    totalCostText: {
        fontSize: 16,
        fontWeight: 'bold',
    },
    checkboxContainer: { flexDirection: 'row', alignItems: 'center', marginBottom: 10, paddingVertical: 5 },
    checkbox: { width: 22, height: 22, borderWidth: 1.5, borderColor: 'rgb(249, 71, 208)', marginRight: 12, borderRadius: 100, backgroundColor: '#fff' },
    checkboxSelected: { backgroundColor: 'rgb(249, 71, 208)' },
    checkboxLabel: { fontSize: 16, flexShrink: 1 },
    button: { backgroundColor: 'rgb(249, 71, 208)', padding: 15, borderRadius: 8, alignItems: 'center', marginTop: 20 },
    buttonDisabled: { backgroundColor: '#A9A9A9' },
    buttonText: { color: 'white', fontWeight: 'bold', fontSize: 16 },
    placeholderText: { color: 'grey', marginVertical: 10, fontStyle: 'italic', textAlign: 'center', padding: 10, borderWidth: 1, borderColor: 'lightgrey', borderStyle: 'dashed' },
    selectedTestsSection: {
        marginTop: 10,
        padding: 10,
        borderWidth: 1,
        borderColor: '#e0e0e0',
        borderRadius: 5,
        gap: 10,
    },
    selectedTestItem: {
        paddingBottom: 10,
        borderBottomWidth: 1,
        borderBottomColor: '#f0f0f0',
        gap: 5,
    }
});